= RFC 0000: A Textual Format for HTTP API Test Scenarios
:toc:
:toc-placement: preamble
:sectnums:

[NOTE]
====
WIP.

TODO : bibliography ? (format http).

TODO : global variable that MUST be available

TODO : usual section about MUST/SHOULD/etc...
====

*Abstract*

This document specifies a textual file format designed for defining and executing test scenarios against Application Programming Interfaces (APIs) that communicate over the Hypertext Transfer Protocol (HTTP). The format emphasizes readability and simplicity, leveraging Github Flavored Markdown (GFM) for its structure. It provides a clear separation between global setup, per-step execution, and individual HTTP requests, along with optional scripting capabilities.

== Introduction

Modern software development heavily relies on robust Application Programming Interfaces (APIs). Ensuring the correctness and reliability of these APIs requires comprehensive testing. This document proposes a human-readable and machine-parsable file format for defining test scenarios. The format aims to standardize how test sequences, including HTTP requests, pre-request logic, and post-request validations, are described in a plain text file. This approach facilitates version control, collaboration, and automated execution of API tests.

== Core Concepts

=== Section of a markdown document

Let's define a _section_ of a markdown document : a section starts with a header line (included), and ends at the next header line having the same level or a lower level (excluded), or ends at the end of the document.

The _level_ of the section is the level of the header that marks its start.

A _sub-section_ is a section contained in a section of lower level.

==== Example

Given the following document

[source,markdown]
----
# Title

## Part 1

Content of part 1

### Detail 1

Content of detail 1

#### example

An example for detail 1

### Detail 2

Centent of detail 2

## Part 2

Content of part 2
----

The section entitled _Part 1_ ends where the section entitled _Part 2_ begins, the later ends at the end of the document.

In section _Part 1_, there is a sub-section entitled _Detail 1_ that ends weher the sub-section _Detail 2_ begins ; the later ends at the begining of the section _Part 2_.

_Part 1_ and _Part 2_ are level 2 sections ; _Detail 1_ and _Detail 2_ are level 3 sections.

=== "Key expressions" to identify parts of the test scenario

A test scenario file is a GFM document that contains a single level 1 section, whose title is the title of the scenario.

That section contains level 2 sections that are identified as parts of the screnario by having their title starting with a _key expressions_. 

A key expression is a string enclosed by colons (e.g., `:KeyExpression:`), and it is case-insensitive. 

Any section that does not begin with a key expression is considered a comment and is ignored by parsers.

The expected sections of a test scenario are:

* *:Preamble:*: Defines global configurations and hooks that execute before, between, or after test steps. *There is _only one_ `:Preamble:` section.*
* *:Step:*: Defines individual test actions, typically involving an HTTP request and associated logic. *There is _at least one_ `:Step:` section.*

Sections are declared sequentially within the file.

=== Programming language support

Testing an API using a scenario, i.e. a sequence of API calls, requires some processing in between the actual calls.

This document will describe the means provided to specify the actual processing using a programming language.

There is no constraint about the programming language to use.

On the other hand, there are two rules to follow :

* There is only one programming language used throughout the scenario. E.g., one cannot find some fenced blocks in Javascript, and other fenced blocks in Python. _The document is malformed in such case._
* The fenced blocks containing statements in the chosen programming language MUST target that programming language. E.g. a scenario that uses the Java programming language MUST use the keyword `java` for its fenced blocks describing the processings.

_For the sake of simplicity, this document will provides sample scenario that uses Javascript._

== The Preamble Section

The `:Preamble:` section is an optional, single section at the beginning of the file. It serves to configure the testing environment and define reusable setup/teardown actions. Any text directly within the `:Preamble:` section but outside its sub-sections is considered a comment.

The `:Preamble:` section may contain the following sub-sections (header line starting with 3 hash characters `###`), which must appear in the order listed below if present:

* *:Globals:*
* *:Before all:*
* *:Before each:*
* *:After each:*
* *:After all:*

Each of these sub-sections defines a specific execution hook or configuration scope.

=== The :Globals: Sub-section

The `:Globals:` sub-section is optional and may appear at most once within the `:Preamble:`. Its primary purpose is to define global variables or import necessary JavaScript modules that will be accessible throughout the test scenario.

The content of the `:Globals:` sub-section consists of a single, mandatory fenced code block, which MUST be of type `javascript`. Any text outside this specific JavaScript block within the `:Globals:` sub-section is treated as a comment.

Example:

[source,markdown]
----
## :Preamble:
This is a comment about the preamble.

### :Globals:
These are global definitions.
```js
// specify javascript imports
// Define "Environment variables"
const baseUrl = "https://api.example.com/v1";
let authToken = ""; // This will be populated later.
```
----

=== The :Before all: Sub-section

The `:Before all:` sub-section is optional and may appear at most once within the `:Preamble:`. It contains JavaScript code that is executed once before any test step begins, and prior to the first execution of any `:Before each:` script.

The content of the `:Before all:` sub-section consists of a single, mandatory fenced code block, which MUST be of type `javascript`. Any text outside this JavaScript block is treated as a comment.

Example:

[source,markdown]
----
### :Before all:
This script runs once before all steps.
```js
// Javascript to execute once before starting any step
// (before the first "before each" if any)
console.log("Starting test suite...");
// e.g., obtain an initial global token
```
----

=== The :Before each: Sub-section

The `:Before each:` sub-section is optional and may appear at most once within the `:Preamble:`. It contains JavaScript code that is executed before each individual test step is processed.

The content of the `:Before each:` sub-section consists of a single, mandatory fenced code block, which MUST be of type `javascript`. Any text outside this JavaScript block is treated as a comment.

Example:

[source,markdown]
----
### :Before each:
This script runs before every step.
```js
// Javascript to execute before each step
console.log(`Executing step ${currentStepNumber}...`);
// e.g., reset a state or log step start
```
----

=== The :After each: Sub-section

The `:After each:` sub-section is optional and may appear at most once within the `:Preamble:`. It contains JavaScript code that is executed after each individual test step has completed its HTTP request and post-request script.

The content of the `:After each:` sub-section consists of a single, mandatory fenced code block, which MUST be of type `javascript`. Any text outside this JavaScript block is treated as a comment.

Example:

[source,markdown]
----
### :After each:
This script runs after every step.
```js
// Javascript to execute after each step
console.log(`Step ${currentStepNumber} finished.`);
// e.g., log step duration or clean up per-step resources
```
----

=== The :After all: Sub-section

The `:After all:` sub-section is optional and may appear at most once within the `:Preamble:`. It contains JavaScript code that is executed once after all test steps have completed, including their respective `:After each:` scripts.

The content of the `:After all:` sub-section consists of a single, mandatory fenced code block, which MUST be of type `javascript`. Any text outside this JavaScript block is treated as a comment.

Example:

[source,markdown]
----
### :After all:
This script runs once after all steps.
```js
// Javascript to execute once after the last step
// (after the last "before each" if any)
console.log("Test suite finished.");
// e.g., generate a summary report or clean up global resources
```
----

== The Step Section

The `:Step:` section (header line starting with 2 hash characters `##`) defines an individual test action. A test scenario file consists of one or more `:Step:` sections, which are processed in the order they appear in the file.

Each `:Step:` section begins with the `:Step:` key expression, optionnally followed by a step number and a descriptive text. The step number and the descriptive text after it are considered a comment and can be used for clarity, logging, or generating test function names.

Example:

[source,markdown]
----
## :Step: 1. Authenticate User
----

Within a `:Step:` section, the following components can appear in sequence:

. *Optional Pre-request Script*: A fenced code block of type `javascript`.
. *Mandatory HTTP Request*: A fenced code block of type `http`.
. *Optional Post-request Script*: A fenced code block of type `javascript`.

Any text within a `:Step:` section that is not part of these fenced code blocks is treated as a comment.

=== Pre-request Script

This optional JavaScript block executes immediately before the HTTP request for the current step is sent. It can be used to prepare request parameters, calculate dynamic values, or set up local state for the step.

Example:

[source,markdown]
----
```js
// optionnal pre-request script
const queryParams = new URLSearchParams({
    status: "active",
    limit: 10
});
pm.variables.set("productsQuery", queryParams.toString());
```
----

=== HTTP Request

This is a mandatory section within each `:Step:`. It defines the actual HTTP request to be made. The content must be a fenced code block of type `http`. The block is _malformed_ when it contains more than one request.

Variables defined in `:Globals:` or set within JavaScript scripts (e.g., pre-request or post-request scripts) can be used within the HTTP request block by enclosing their names in double curly braces (e.g., `{{my_variable}}`).

The format of the HTTP request block generally follows common conventions for defining HTTP messages, including the method, Uniform Resource Identifier (URI), headers, and body.

Example:

[source,markdown]
----
```http
GET {{baseUrl}}/products?{{productsQuery}}
Accept: application/json
Authorization: Bearer {{authToken}}
```
----

=== Post-request Script

This optional JavaScript block executes immediately after the HTTP response for the current step has been received. It is typically used for:

* Validating the response (e.g., status code, body content, headers).
* Extracting data from the response to be used in subsequent steps.
* Logging or reporting test outcomes.

Example:

[source,markdown]
----
```js
// optionnal post-request script
// Check status code
if (response.status !== 200) {
    throw new Error(`Expected status 200 but got ${response.status}`);
}
// Store a value for next step
const responseBody = JSON.parse(response.body);
pm.variables.set("firstProductId", responseBody.data[0].id);
```
----

== File Structure and Comments

The test scenario file uses Github Flavored Markdown (GFM). Key expressions are put in headers. Any line or block of text that is not explicitly part of a key expression's defined content (like a JavaScript or HTTP block) or another key expression is considered a comment. This allows for liberal use of descriptive text to enhance readability.

The order of sections is strict:

. Optional `:Preamble:` section (if present, its sub-sections must be in order).
. One or more `:Step:` sections, in sequential order.

[appendix]
== Acronyms

*API*:: Application Programming Interface. A set of definitions and protocols for building and integrating application software.
*GFM*:: Github Flavored Markdown. A dialect of Markdown that is used on GitHub and other platforms.
*HTTP*:: Hypertext Transfer Protocol. An application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can be used for other purposes as well.
*IETF*:: Internet Engineering Task Force. An organization that develops and promotes Internet standards.
*RFC*:: Request For Comments. A formal document series from the IETF that describes the Internet's technical specifications and organizational notes.
*URI*:: Uniform Resource Identifier. A sequence of characters that identifies a logical or physical resource.